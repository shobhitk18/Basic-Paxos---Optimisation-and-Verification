# -*- generated by 1.0.12 -*-
import da
PatternExpr_263 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern266_'), da.pat.FreePattern(None)])
PatternExpr_270 = da.pat.FreePattern('a')
PatternExpr_298 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern301_'), da.pat.TuplePattern([da.pat.FreePattern('n2'), da.pat.FreePattern('v')])])
PatternExpr_329 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern332_'), da.pat.TuplePattern([da.pat.FreePattern('n2'), da.pat.FreePattern(None)])])
PatternExpr_365 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern368_'), da.pat.FreePattern(None)])
PatternExpr_372 = da.pat.FreePattern('a')
PatternExpr_413 = da.pat.TuplePattern([da.pat.ConstantPattern('preempt'), da.pat.FreePattern('val')])
PatternExpr_420 = da.pat.FreePattern('a')
PatternExpr_454 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_459 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('done')])])
PatternExpr_595 = da.pat.TuplePattern([da.pat.ConstantPattern('prepare'), da.pat.FreePattern('n')])
PatternExpr_602 = da.pat.FreePattern('p')
PatternExpr_608 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.FreePattern('n2'), da.pat.FreePattern(None)])
PatternExpr_637 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.FreePattern('n'), da.pat.FreePattern('v')])
PatternExpr_663 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.FreePattern('n'), da.pat.FreePattern(None)])
PatternExpr_714 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.FreePattern('n2'), da.pat.FreePattern(None)])
PatternExpr_745 = da.pat.TuplePattern([da.pat.ConstantPattern('accept'), da.pat.FreePattern('n'), da.pat.FreePattern('v')])
PatternExpr_758 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.FreePattern('n2'), da.pat.FreePattern(None)])
PatternExpr_874 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_879 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('done')])])
PatternExpr_943 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.FreePattern('n'), da.pat.FreePattern('v')])
PatternExpr_969 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.BoundPattern('_BoundPattern972_'), da.pat.BoundPattern('_BoundPattern973_')])
PatternExpr_976 = da.pat.FreePattern('a')
PatternExpr_1314 = da.pat.TuplePattern([da.pat.ConstantPattern('learned')])
PatternExpr_1319 = da.pat.BoundPattern('_BoundPattern1320_')
PatternExpr_1347 = da.pat.TuplePattern([da.pat.ConstantPattern('learned_val'), da.pat.FreePattern('val')])
PatternExpr_1354 = da.pat.FreePattern('a')
PatternExpr_1442 = da.pat.TuplePattern([da.pat.ConstantPattern('Stats'), da.pat.FreePattern('data'), da.pat.FreePattern('n')])
PatternExpr_1321 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern1327_')]), da.pat.TuplePattern([da.pat.ConstantPattern('learned')])])
_config_object = {}
import sys
from random import randint
import csv
import time as t
controller = da.import_da('controller')

class Proposer(controller.Controllee, da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._ProposerReceivedEvent_0 = []
        self._ProposerReceivedEvent_1 = []
        self._ProposerReceivedEvent_2 = []
        self._ProposerReceivedEvent_3 = []
        self._ProposerReceivedEvent_4 = []
        self._ProposerReceivedEvent_5 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_0', PatternExpr_263, sources=[PatternExpr_270], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_1', PatternExpr_298, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_2', PatternExpr_329, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_3', PatternExpr_365, sources=[PatternExpr_372], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_4', PatternExpr_413, sources=[PatternExpr_420], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_5', PatternExpr_454, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, ctl, acceptors, loss_rate, msg_delay, wait_delay, timeout, **rest_1524):
        super().setup(ctl=ctl, acceptors=acceptors, loss_rate=loss_rate, msg_delay=msg_delay, wait_delay=wait_delay, timeout=timeout, **rest_1524)
        self._state.ctl = ctl
        self._state.acceptors = acceptors
        self._state.loss_rate = loss_rate
        self._state.msg_delay = msg_delay
        self._state.wait_delay = wait_delay
        self._state.timeout = timeout
        super().setup(self._state.ctl)
        self._state.pmsg_to_drop = 0
        self._state.amsg_to_drop = 0
        self._state.n = None
        self._state.majority = self._state.acceptors

    @controller.run
    def run(self):
        while (not PatternExpr_459.match_iter(self._ProposerReceivedEvent_5, SELF_ID=self._id)):
            self.to_consent()
            t.sleep(self._state.wait_delay)
        self.output('terminating')

    def to_consent(self):
        self._state.n = ((0, self._id) if (self._state.n == None) else ((self._state.n[0] + 1), self._id))
        is_drop = self.handle_msg_delay_loss(self._state.loss_rate, self._state.msg_delay, 'prepare')
        if (not is_drop):
            self._state.pmsg_to_drop += 1
            self.send(('prepare', self._state.n), to=self._state.majority)
        super()._label('_st_label_258', block=False)
        val = a = None

        def ExistentialOpExpr_411():
            nonlocal val, a
            for (_, (_, _, a), (_ConstantPattern431_, val)) in self._ProposerReceivedEvent_4:
                if (_ConstantPattern431_ == 'preempt'):
                    if (val > self._state.n):
                        return True
            return False
        _st_label_258 = 0
        self._timer_start()
        while (_st_label_258 == 0):
            _st_label_258 += 1
            if (len({a for (_, (_, _, a), (_ConstantPattern281_, _BoundPattern283_, _)) in self._ProposerReceivedEvent_0 if (_ConstantPattern281_ == 'respond') if (_BoundPattern283_ == self._state.n)}) > (len(self._state.acceptors) / 2)):
                v = self.anyof(({v for (_, _, (_ConstantPattern317_, _BoundPattern319_, (n2, v))) in self._ProposerReceivedEvent_1 if (_ConstantPattern317_ == 'respond') if (_BoundPattern319_ == self._state.n) if (n2 == max({n2 for (_, _, (_ConstantPattern346_, _BoundPattern348_, (n2, _))) in self._ProposerReceivedEvent_2 if (_ConstantPattern346_ == 'respond') if (_BoundPattern348_ == self._state.n)}))} or {randint(1, 100)}))
                responded = {a for (_, (_, _, a), (_ConstantPattern383_, _BoundPattern385_, _)) in self._ProposerReceivedEvent_3 if (_ConstantPattern383_ == 'respond') if (_BoundPattern385_ == self._state.n)}
                is_drop = self.handle_msg_delay_loss(self._state.loss_rate, self._state.msg_delay, 'prepare')
                if (not is_drop):
                    self._state.amsg_to_drop += 1
                    self.send(('accept', self._state.n, v), to=responded)
                _st_label_258 += 1
            elif ExistentialOpExpr_411():
                self._state.n = val
                _st_label_258 += 1
            elif self._timer_expired:
                self.output('failed proposal number', self._state.n)
                _st_label_258 += 1
            else:
                super()._label('_st_label_258', block=True, timeout=self._state.timeout)
                _st_label_258 -= 1

    def handle_msg_delay_loss(self, loss_rate, msg_delay, req_type):
        if msg_delay:
            t.sleep(msg_delay)
        if ((req_type == 'prepare') and (not (loss_rate == 0)) and (self._state.pmsg_to_drop == int((1 / loss_rate)))):
            self._state.pmsg_to_drop = 0
            print('************Prepare Message is dropped************')
            return True
        if ((req_type == 'accept') and (not (loss_rate == 0)) and (self._state.amsg_to_drop == int((1 / loss_rate)))):
            print('************Accept message is dropped************')
            self._state.amsg_to_drop = 0
            return True
        return False

    def anyof(self, s):
        return (next(iter(s)) if s else None)

@controller.rugroup('bo_measured')
class Acceptor(controller.Controllee, da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._AcceptorSentEvent_1 = []
        self._AcceptorSentEvent_2 = []
        self._AcceptorSentEvent_3 = []
        self._AcceptorSentEvent_4 = []
        self._AcceptorSentEvent_6 = []
        self._AcceptorReceivedEvent_7 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_AcceptorReceivedEvent_0', PatternExpr_595, sources=[PatternExpr_602], destinations=None, timestamps=None, record_history=None, handlers=[self._Acceptor_handler_594]), da.pat.EventPattern(da.pat.SentEvent, '_AcceptorSentEvent_1', PatternExpr_608, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.SentEvent, '_AcceptorSentEvent_2', PatternExpr_637, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.SentEvent, '_AcceptorSentEvent_3', PatternExpr_663, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.SentEvent, '_AcceptorSentEvent_4', PatternExpr_714, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_AcceptorReceivedEvent_5', PatternExpr_745, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Acceptor_handler_744]), da.pat.EventPattern(da.pat.SentEvent, '_AcceptorSentEvent_6', PatternExpr_758, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_AcceptorReceivedEvent_7', PatternExpr_874, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, ctl, learners, loss_rate, msg_delay, **rest_1524):
        super().setup(ctl=ctl, learners=learners, loss_rate=loss_rate, msg_delay=msg_delay, **rest_1524)
        self._state.ctl = ctl
        self._state.learners = learners
        self._state.loss_rate = loss_rate
        self._state.msg_delay = msg_delay
        super().setup(self._state.ctl)
        self._state.respond_to_drop = 0
        self._state.accepted_to_drop = 0

    @controller.run
    def run(self):
        super()._label('_st_label_871', block=False)
        _st_label_871 = 0
        while (_st_label_871 == 0):
            _st_label_871 += 1
            if PatternExpr_879.match_iter(self._AcceptorReceivedEvent_7, SELF_ID=self._id):
                _st_label_871 += 1
            else:
                super()._label('_st_label_871', block=True)
                _st_label_871 -= 1
        self.output('terminating')

    def handle_msg_delay_loss(self, loss_rate, msg_delay, req_type):
        if msg_delay:
            t.sleep(msg_delay)
        if ((req_type == 'respond') and (not (loss_rate == 0)) and (self._state.respond_to_drop == int((1 / loss_rate)))):
            self._state.respond_to_drop = 0
            print('************Respond Message is dropped************')
            return True
        if ((req_type == 'accepted') and (not (loss_rate == 0)) and (self._state.accepted_to_drop == int((1 / loss_rate)))):
            self._state.accepted_to_drop = 0
            print('************Accepted Message is dropped***********')
            return True
        return False

    def anyof(self, s):
        "return any element of set s if s is not empty or 'None' otherwise"
        return (next(iter(s)) if s else None)

    def _Acceptor_handler_594(self, n, p):
        n2 = None

        def UniversalOpExpr_606():
            nonlocal n2
            for (_, _, (_ConstantPattern624_, n2, _)) in self._AcceptorSentEvent_1:
                if (_ConstantPattern624_ == 'respond'):
                    if (not (n > n2)):
                        return False
            return True
        if UniversalOpExpr_606():
            maxprop = self.anyof({(n, v) for (_, _, (_ConstantPattern653_, n, v)) in self._AcceptorSentEvent_2 if (_ConstantPattern653_ == 'accepted') if (n == max({n for (_, _, (_ConstantPattern678_, n, _)) in self._AcceptorSentEvent_3 if (_ConstantPattern678_ == 'accepted')}))})
            is_drop = self.handle_msg_delay_loss(self._state.loss_rate, self._state.msg_delay, 'respond')
            if (not is_drop):
                self._state.respond_to_drop += 1
                self.send(('respond', n, maxprop), to=p)
        else:
            preempt_n = max({n2 for (_, _, (_ConstantPattern729_, n2, _)) in self._AcceptorSentEvent_4 if (_ConstantPattern729_ == 'respond')})
            self.send(('preempt', preempt_n), to=p)
    _Acceptor_handler_594._labels = None
    _Acceptor_handler_594._notlabels = None

    def _Acceptor_handler_744(self, n, v):
        n2 = None

        def ExistentialOpExpr_756():
            nonlocal n2
            for (_, _, (_ConstantPattern774_, n2, _)) in self._AcceptorSentEvent_6:
                if (_ConstantPattern774_ == 'respond'):
                    if (n2 > n):
                        return True
            return False
        if (not ExistentialOpExpr_756()):
            is_drop = self.handle_msg_delay_loss(self._state.loss_rate, self._state.msg_delay, 'accepted')
            if (not is_drop):
                self._state.respond_to_drop += 1
                self.send(('accepted', n, v), to=self._state.learners)
    _Acceptor_handler_744._labels = None
    _Acceptor_handler_744._notlabels = None

class Learner(controller.Controllee, da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._LearnerReceivedEvent_0 = []
        self._LearnerReceivedEvent_1 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_LearnerReceivedEvent_0', PatternExpr_943, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_LearnerReceivedEvent_1', PatternExpr_969, sources=[PatternExpr_976], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, ctl, acceptors, timeout, **rest_1524):
        super().setup(ctl=ctl, acceptors=acceptors, timeout=timeout, **rest_1524)
        self._state.ctl = ctl
        self._state.acceptors = acceptors
        self._state.timeout = timeout
        super().setup(self._state.ctl)
        self._state.learned_val = None
        self._state.is_timeout = False

    @controller.run
    def run(self):
        self.learn()
        self.output('terminating')
        self.send(('learned_val', (self._state.is_timeout, self._state.learned_val)), to=self.nodeof(self._id))
        self.send(('learned',), to=self.nodeof(self._id))

    def learn(self):
        super()._label('_st_label_940', block=False)
        v = a = n = None

        def ExistentialOpExpr_941():
            nonlocal v, a, n
            for (_, _, (_ConstantPattern960_, n, v)) in self._LearnerReceivedEvent_0:
                if (_ConstantPattern960_ == 'accepted'):
                    if (len({a for (_, (_, _, a), (_ConstantPattern987_, _BoundPattern989_, _BoundPattern990_)) in self._LearnerReceivedEvent_1 if (_ConstantPattern987_ == 'accepted') if (_BoundPattern989_ == n) if (_BoundPattern990_ == v)}) > (len(self._state.acceptors) / 2)):
                        return True
            return False
        _st_label_940 = 0
        self._timer_start()
        while (_st_label_940 == 0):
            _st_label_940 += 1
            if ExistentialOpExpr_941():
                self.output('learned', n, v)
                self._state.learned_val = v
                _st_label_940 += 1
            elif self._timer_expired:
                self._state.is_timeout = True
                self.output('failed learning anything')
                _st_label_940 += 1
            else:
                super()._label('_st_label_940', block=True, timeout=self._state.timeout)
                _st_label_940 -= 1

class Node_(da.NodeProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._Node_ReceivedEvent_0 = []
        self._Node_ReceivedEvent_1 = []
        self._Node_ReceivedEvent_2 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_0', PatternExpr_1314, sources=[PatternExpr_1319], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_1', PatternExpr_1347, sources=[PatternExpr_1354], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_2', PatternExpr_1442, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def run(self):
        nacceptors = (int(sys.argv[1]) if (len(sys.argv) > 1) else 3)
        nproposers = (int(sys.argv[2]) if (len(sys.argv) > 2) else 5)
        nlearners = (int(sys.argv[3]) if (len(sys.argv) > 3) else 3)
        num_reps = (int(sys.argv[4]) if (len(sys.argv) > 4) else 1)
        loss_rate = (float(sys.argv[5]) if (len(sys.argv) > 5) else 0)
        msg_delay = (float(sys.argv[6]) if (len(sys.argv) > 6) else 0)
        wait_delay = (float(sys.argv[7]) if (len(sys.argv) > 7) else 0)
        p_timeout = (float(sys.argv[8]) if (len(sys.argv) > 8) else 1)
        l_timeout = (float(sys.argv[9]) if (len(sys.argv) > 9) else 10)
        print('loss_rate', loss_rate)
        print('msg_delay', msg_delay)
        print('wait_delay', wait_delay)
        result = []
        itr = 0
        is_timeout = []
        is_corr = []
        for i in range(num_reps):
            acceptors = self.new(Acceptor, num=nacceptors)
            proposers = self.new(Proposer, num=nproposers)
            learners = self.new(Learner, num=nlearners)
            ctl = self.new(controller.Controller, num=1)
            self._setup(ctl, (((nacceptors + nproposers) + nlearners),))
            self._start(ctl)
            for a in acceptors:
                self._setup(a, (ctl, learners, loss_rate, msg_delay))
            for p in proposers:
                self._setup(p, (ctl, acceptors, loss_rate, msg_delay, wait_delay, p_timeout))
            for l in learners:
                self._setup(l, (ctl, acceptors, l_timeout))
            self._start(((acceptors | proposers) | learners))
            super()._label('_st_label_1306', block=False)
            l = None

            def UniversalOpExpr_1307():
                nonlocal l
                for l in learners:
                    if (not PatternExpr_1321.match_iter(self._Node_ReceivedEvent_0, _BoundPattern1327_=l)):
                        return False
                return True
            _st_label_1306 = 0
            while (_st_label_1306 == 0):
                _st_label_1306 += 1
                if UniversalOpExpr_1307():
                    _st_label_1306 += 1
                else:
                    super()._label('_st_label_1306', block=True)
                    _st_label_1306 -= 1
            else:
                if (_st_label_1306 != 2):
                    continue
            if (_st_label_1306 != 2):
                break
            l_val = set()
            t = False
            for l in learners:
                learned = {val for (_, (_, _, a), (_ConstantPattern1364_, val)) in self._Node_ReceivedEvent_1 if (_ConstantPattern1364_ == 'learned_val') if (a == l)}
                learned = list(learned)
                t = (t or learned[0][0])
                l_val.add(learned[0][1])
            if t:
                is_timeout.append(1)
            else:
                is_timeout.append(0)
            if (len(l_val) > 1):
                is_corr.append(0)
            else:
                is_corr.append(1)
            self.output('done')
            self.send(('done',), to=(acceptors | proposers))
            self.send(('Get_Stats', itr), to=ctl)
            super()._label('_st_label_1439', block=False)
            data = n = None

            def ExistentialOpExpr_1440():
                nonlocal data, n
                for (_, _, (_ConstantPattern1459_, data, n)) in self._Node_ReceivedEvent_2:
                    if (_ConstantPattern1459_ == 'Stats'):
                        if (n == itr):
                            return True
                return False
            _st_label_1439 = 0
            while (_st_label_1439 == 0):
                _st_label_1439 += 1
                if ExistentialOpExpr_1440():
                    temp = list(data)
                    temp.append(is_timeout[i])
                    temp.append(is_corr[i])
                    data = tuple(temp)
                    result += list((data,))
                    _st_label_1439 += 1
                else:
                    super()._label('_st_label_1439', block=True)
                    _st_label_1439 -= 1
            else:
                if (_st_label_1439 != 2):
                    continue
            if (_st_label_1439 != 2):
                break
            with open('temp.csv', mode='a') as output_file:
                writer = csv.writer(output_file)
                writer.writerow(list(result[i]))
            itr += 1
