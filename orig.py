# -*- generated by 1.0.12 -*-
import da
PatternExpr_263 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern266_'), da.pat.FreePattern(None)])
PatternExpr_270 = da.pat.FreePattern('a')
PatternExpr_298 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern301_'), da.pat.TuplePattern([da.pat.FreePattern('n2'), da.pat.FreePattern('v')])])
PatternExpr_329 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern332_'), da.pat.TuplePattern([da.pat.FreePattern('n2'), da.pat.FreePattern(None)])])
PatternExpr_365 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern368_'), da.pat.FreePattern(None)])
PatternExpr_372 = da.pat.FreePattern('a')
PatternExpr_423 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_428 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('done')])])
PatternExpr_564 = da.pat.TuplePattern([da.pat.ConstantPattern('prepare'), da.pat.FreePattern('n')])
PatternExpr_571 = da.pat.FreePattern('p')
PatternExpr_577 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.FreePattern('n2'), da.pat.FreePattern(None)])
PatternExpr_606 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.FreePattern('n'), da.pat.FreePattern('v')])
PatternExpr_632 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.FreePattern('n'), da.pat.FreePattern(None)])
PatternExpr_681 = da.pat.TuplePattern([da.pat.ConstantPattern('accept'), da.pat.FreePattern('n'), da.pat.FreePattern('v')])
PatternExpr_694 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.FreePattern('n2'), da.pat.FreePattern(None)])
PatternExpr_810 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_815 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('done')])])
PatternExpr_879 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.FreePattern('n'), da.pat.FreePattern('v')])
PatternExpr_905 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.BoundPattern('_BoundPattern908_'), da.pat.BoundPattern('_BoundPattern909_')])
PatternExpr_912 = da.pat.FreePattern('a')
PatternExpr_1250 = da.pat.TuplePattern([da.pat.ConstantPattern('learned')])
PatternExpr_1255 = da.pat.BoundPattern('_BoundPattern1256_')
PatternExpr_1283 = da.pat.TuplePattern([da.pat.ConstantPattern('learned_val'), da.pat.FreePattern('val')])
PatternExpr_1290 = da.pat.FreePattern('a')
PatternExpr_1378 = da.pat.TuplePattern([da.pat.ConstantPattern('Stats'), da.pat.FreePattern('data'), da.pat.FreePattern('n')])
PatternExpr_1257 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern1263_')]), da.pat.TuplePattern([da.pat.ConstantPattern('learned')])])
_config_object = {}
import sys
from random import randint
import csv
import time as t
controller = da.import_da('controller')

class Proposer(controller.Controllee, da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._ProposerReceivedEvent_0 = []
        self._ProposerReceivedEvent_1 = []
        self._ProposerReceivedEvent_2 = []
        self._ProposerReceivedEvent_3 = []
        self._ProposerReceivedEvent_4 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_0', PatternExpr_263, sources=[PatternExpr_270], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_1', PatternExpr_298, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_2', PatternExpr_329, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_3', PatternExpr_365, sources=[PatternExpr_372], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_4', PatternExpr_423, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, ctl, acceptors, loss_rate, msg_delay, wait_delay, timeout, **rest_1460):
        super().setup(ctl=ctl, acceptors=acceptors, loss_rate=loss_rate, msg_delay=msg_delay, wait_delay=wait_delay, timeout=timeout, **rest_1460)
        self._state.ctl = ctl
        self._state.acceptors = acceptors
        self._state.loss_rate = loss_rate
        self._state.msg_delay = msg_delay
        self._state.wait_delay = wait_delay
        self._state.timeout = timeout
        super().setup(self._state.ctl)
        self._state.pmsg_to_drop = 0
        self._state.amsg_to_drop = 0
        self._state.n = None
        self._state.majority = self._state.acceptors

    @controller.run
    def run(self):
        while (not PatternExpr_428.match_iter(self._ProposerReceivedEvent_4, SELF_ID=self._id)):
            self.to_consent()
            t.sleep(self._state.wait_delay)
        self.output('terminating')

    def to_consent(self):
        self._state.n = ((0, self._id) if (self._state.n == None) else ((self._state.n[0] + 1), self._id))
        is_drop = self.handle_msg_delay_loss(self._state.loss_rate, self._state.msg_delay, 'prepare')
        if (not is_drop):
            self._state.pmsg_to_drop += 1
            self.send(('prepare', self._state.n), to=self._state.majority)
        super()._label('_st_label_258', block=False)
        _st_label_258 = 0
        self._timer_start()
        while (_st_label_258 == 0):
            _st_label_258 += 1
            if (len({a for (_, (_, _, a), (_ConstantPattern281_, _BoundPattern283_, _)) in self._ProposerReceivedEvent_0 if (_ConstantPattern281_ == 'respond') if (_BoundPattern283_ == self._state.n)}) > (len(self._state.acceptors) / 2)):
                v = self.anyof(({v for (_, _, (_ConstantPattern317_, _BoundPattern319_, (n2, v))) in self._ProposerReceivedEvent_1 if (_ConstantPattern317_ == 'respond') if (_BoundPattern319_ == self._state.n) if (n2 == max({n2 for (_, _, (_ConstantPattern346_, _BoundPattern348_, (n2, _))) in self._ProposerReceivedEvent_2 if (_ConstantPattern346_ == 'respond') if (_BoundPattern348_ == self._state.n)}))} or {randint(1, 100)}))
                responded = {a for (_, (_, _, a), (_ConstantPattern383_, _BoundPattern385_, _)) in self._ProposerReceivedEvent_3 if (_ConstantPattern383_ == 'respond') if (_BoundPattern385_ == self._state.n)}
                is_drop = self.handle_msg_delay_loss(self._state.loss_rate, self._state.msg_delay, 'prepare')
                if (not is_drop):
                    self._state.amsg_to_drop += 1
                    self.send(('accept', self._state.n, v), to=responded)
                _st_label_258 += 1
            elif self._timer_expired:
                self.output('failed proposal number', self._state.n)
                _st_label_258 += 1
            else:
                super()._label('_st_label_258', block=True, timeout=self._state.timeout)
                _st_label_258 -= 1

    def handle_msg_delay_loss(self, loss_rate, msg_delay, req_type):
        if msg_delay:
            t.sleep(msg_delay)
        if ((req_type == 'prepare') and (not (loss_rate == 0)) and (self._state.pmsg_to_drop == int((1 / loss_rate)))):
            self._state.pmsg_to_drop = 0
            print('************Prepare Message is dropped************')
            return True
        if ((req_type == 'accept') and (not (loss_rate == 0)) and (self._state.amsg_to_drop == int((1 / loss_rate)))):
            print('************Accept message is dropped************')
            self._state.amsg_to_drop = 0
            return True
        return False

    def anyof(self, s):
        return (next(iter(s)) if s else None)

@controller.rugroup('bo_measured')
class Acceptor(controller.Controllee, da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._AcceptorSentEvent_1 = []
        self._AcceptorSentEvent_2 = []
        self._AcceptorSentEvent_3 = []
        self._AcceptorSentEvent_5 = []
        self._AcceptorReceivedEvent_6 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_AcceptorReceivedEvent_0', PatternExpr_564, sources=[PatternExpr_571], destinations=None, timestamps=None, record_history=None, handlers=[self._Acceptor_handler_563]), da.pat.EventPattern(da.pat.SentEvent, '_AcceptorSentEvent_1', PatternExpr_577, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.SentEvent, '_AcceptorSentEvent_2', PatternExpr_606, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.SentEvent, '_AcceptorSentEvent_3', PatternExpr_632, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_AcceptorReceivedEvent_4', PatternExpr_681, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Acceptor_handler_680]), da.pat.EventPattern(da.pat.SentEvent, '_AcceptorSentEvent_5', PatternExpr_694, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_AcceptorReceivedEvent_6', PatternExpr_810, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, ctl, learners, loss_rate, msg_delay, **rest_1460):
        super().setup(ctl=ctl, learners=learners, loss_rate=loss_rate, msg_delay=msg_delay, **rest_1460)
        self._state.ctl = ctl
        self._state.learners = learners
        self._state.loss_rate = loss_rate
        self._state.msg_delay = msg_delay
        super().setup(self._state.ctl)
        self._state.respond_to_drop = 0
        self._state.accepted_to_drop = 0

    @controller.run
    def run(self):
        super()._label('_st_label_807', block=False)
        _st_label_807 = 0
        while (_st_label_807 == 0):
            _st_label_807 += 1
            if PatternExpr_815.match_iter(self._AcceptorReceivedEvent_6, SELF_ID=self._id):
                _st_label_807 += 1
            else:
                super()._label('_st_label_807', block=True)
                _st_label_807 -= 1
        self.output('terminating')

    def handle_msg_delay_loss(self, loss_rate, msg_delay, req_type):
        if msg_delay:
            t.sleep(msg_delay)
        if ((req_type == 'respond') and (not (loss_rate == 0)) and (self._state.respond_to_drop == int((1 / loss_rate)))):
            self._state.respond_to_drop = 0
            print('************Respond Message is dropped************')
            return True
        if ((req_type == 'accepted') and (not (loss_rate == 0)) and (self._state.accepted_to_drop == int((1 / loss_rate)))):
            self._state.accepted_to_drop = 0
            print('************Accepted Message is dropped***********')
            return True
        return False

    def anyof(self, s):
        "return any element of set s if s is not empty or 'None' otherwise"
        return (next(iter(s)) if s else None)

    def _Acceptor_handler_563(self, n, p):
        n2 = None

        def UniversalOpExpr_575():
            nonlocal n2
            for (_, _, (_ConstantPattern593_, n2, _)) in self._AcceptorSentEvent_1:
                if (_ConstantPattern593_ == 'respond'):
                    if (not (n > n2)):
                        return False
            return True
        if UniversalOpExpr_575():
            maxprop = self.anyof({(n, v) for (_, _, (_ConstantPattern622_, n, v)) in self._AcceptorSentEvent_2 if (_ConstantPattern622_ == 'accepted') if (n == max({n for (_, _, (_ConstantPattern647_, n, _)) in self._AcceptorSentEvent_3 if (_ConstantPattern647_ == 'accepted')}))})
            is_drop = self.handle_msg_delay_loss(self._state.loss_rate, self._state.msg_delay, 'respond')
            if (not is_drop):
                self._state.respond_to_drop += 1
                self.send(('respond', n, maxprop), to=p)
    _Acceptor_handler_563._labels = None
    _Acceptor_handler_563._notlabels = None

    def _Acceptor_handler_680(self, n, v):
        n2 = None

        def ExistentialOpExpr_692():
            nonlocal n2
            for (_, _, (_ConstantPattern710_, n2, _)) in self._AcceptorSentEvent_5:
                if (_ConstantPattern710_ == 'respond'):
                    if (n2 > n):
                        return True
            return False
        if (not ExistentialOpExpr_692()):
            is_drop = self.handle_msg_delay_loss(self._state.loss_rate, self._state.msg_delay, 'accepted')
            if (not is_drop):
                self._state.respond_to_drop += 1
                self.send(('accepted', n, v), to=self._state.learners)
    _Acceptor_handler_680._labels = None
    _Acceptor_handler_680._notlabels = None

class Learner(controller.Controllee, da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._LearnerReceivedEvent_0 = []
        self._LearnerReceivedEvent_1 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_LearnerReceivedEvent_0', PatternExpr_879, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_LearnerReceivedEvent_1', PatternExpr_905, sources=[PatternExpr_912], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, ctl, acceptors, timeout, **rest_1460):
        super().setup(ctl=ctl, acceptors=acceptors, timeout=timeout, **rest_1460)
        self._state.ctl = ctl
        self._state.acceptors = acceptors
        self._state.timeout = timeout
        super().setup(self._state.ctl)
        self._state.learned_val = None
        self._state.is_timeout = False

    @controller.run
    def run(self):
        self.learn()
        self.output('terminating')
        self.send(('learned_val', (self._state.is_timeout, self._state.learned_val)), to=self.nodeof(self._id))
        self.send(('learned',), to=self.nodeof(self._id))

    def learn(self):
        super()._label('_st_label_876', block=False)
        a = v = n = None

        def ExistentialOpExpr_877():
            nonlocal a, v, n
            for (_, _, (_ConstantPattern896_, n, v)) in self._LearnerReceivedEvent_0:
                if (_ConstantPattern896_ == 'accepted'):
                    if (len({a for (_, (_, _, a), (_ConstantPattern923_, _BoundPattern925_, _BoundPattern926_)) in self._LearnerReceivedEvent_1 if (_ConstantPattern923_ == 'accepted') if (_BoundPattern925_ == n) if (_BoundPattern926_ == v)}) > (len(self._state.acceptors) / 2)):
                        return True
            return False
        _st_label_876 = 0
        self._timer_start()
        while (_st_label_876 == 0):
            _st_label_876 += 1
            if ExistentialOpExpr_877():
                self.output('learned', n, v)
                self._state.learned_val = v
                _st_label_876 += 1
            elif self._timer_expired:
                self._state.is_timeout = True
                self.output('failed learning anything')
                _st_label_876 += 1
            else:
                super()._label('_st_label_876', block=True, timeout=self._state.timeout)
                _st_label_876 -= 1

class Node_(da.NodeProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._Node_ReceivedEvent_0 = []
        self._Node_ReceivedEvent_1 = []
        self._Node_ReceivedEvent_2 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_0', PatternExpr_1250, sources=[PatternExpr_1255], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_1', PatternExpr_1283, sources=[PatternExpr_1290], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_2', PatternExpr_1378, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def run(self):
        nacceptors = (int(sys.argv[1]) if (len(sys.argv) > 1) else 3)
        nproposers = (int(sys.argv[2]) if (len(sys.argv) > 2) else 5)
        nlearners = (int(sys.argv[3]) if (len(sys.argv) > 3) else 3)
        num_reps = (int(sys.argv[4]) if (len(sys.argv) > 4) else 1)
        loss_rate = (float(sys.argv[5]) if (len(sys.argv) > 5) else 0)
        msg_delay = (float(sys.argv[6]) if (len(sys.argv) > 6) else 0)
        wait_delay = (float(sys.argv[7]) if (len(sys.argv) > 7) else 0)
        p_timeout = (float(sys.argv[8]) if (len(sys.argv) > 8) else 1)
        l_timeout = (float(sys.argv[9]) if (len(sys.argv) > 9) else 10)
        print('loss_rate', loss_rate)
        print('msg_delay', msg_delay)
        print('wait_delay', wait_delay)
        result = []
        itr = 0
        is_timeout = []
        is_corr = []
        for i in range(num_reps):
            acceptors = self.new(Acceptor, num=nacceptors)
            proposers = self.new(Proposer, num=nproposers)
            learners = self.new(Learner, num=nlearners)
            ctl = self.new(controller.Controller, num=1)
            self._setup(ctl, (((nacceptors + nproposers) + nlearners),))
            self._start(ctl)
            for a in acceptors:
                self._setup(a, (ctl, learners, loss_rate, msg_delay))
            for p in proposers:
                self._setup(p, (ctl, acceptors, loss_rate, msg_delay, wait_delay, p_timeout))
            for l in learners:
                self._setup(l, (ctl, acceptors, l_timeout))
            self._start(((acceptors | proposers) | learners))
            super()._label('_st_label_1242', block=False)
            l = None

            def UniversalOpExpr_1243():
                nonlocal l
                for l in learners:
                    if (not PatternExpr_1257.match_iter(self._Node_ReceivedEvent_0, _BoundPattern1263_=l)):
                        return False
                return True
            _st_label_1242 = 0
            while (_st_label_1242 == 0):
                _st_label_1242 += 1
                if UniversalOpExpr_1243():
                    _st_label_1242 += 1
                else:
                    super()._label('_st_label_1242', block=True)
                    _st_label_1242 -= 1
            else:
                if (_st_label_1242 != 2):
                    continue
            if (_st_label_1242 != 2):
                break
            l_val = set()
            t = False
            for l in learners:
                learned = {val for (_, (_, _, a), (_ConstantPattern1300_, val)) in self._Node_ReceivedEvent_1 if (_ConstantPattern1300_ == 'learned_val') if (a == l)}
                learned = list(learned)
                t = (t or learned[0][0])
                l_val.add(learned[0][1])
            if t:
                is_timeout.append(1)
            else:
                is_timeout.append(0)
            if (len(l_val) > 1):
                is_corr.append(0)
            else:
                is_corr.append(1)
            self.output('done')
            self.send(('done',), to=(acceptors | proposers))
            self.send(('Get_Stats', itr), to=ctl)
            super()._label('_st_label_1375', block=False)
            n = data = None

            def ExistentialOpExpr_1376():
                nonlocal n, data
                for (_, _, (_ConstantPattern1395_, data, n)) in self._Node_ReceivedEvent_2:
                    if (_ConstantPattern1395_ == 'Stats'):
                        if (n == itr):
                            return True
                return False
            _st_label_1375 = 0
            while (_st_label_1375 == 0):
                _st_label_1375 += 1
                if ExistentialOpExpr_1376():
                    temp = list(data)
                    temp.append(is_timeout[i])
                    temp.append(is_corr[i])
                    data = tuple(temp)
                    result += list((data,))
                    _st_label_1375 += 1
                else:
                    super()._label('_st_label_1375', block=True)
                    _st_label_1375 -= 1
            else:
                if (_st_label_1375 != 2):
                    continue
            if (_st_label_1375 != 2):
                break
            with open('temp.csv', mode='a') as output_file:
                writer = csv.writer(output_file)
                writer.writerow(list(result[i]))
            itr += 1
