# -*- generated by 1.0.12 -*-
import da
PatternExpr_430 = da.pat.TuplePattern([da.pat.ConstantPattern('CTL_Ready')])
PatternExpr_435 = da.pat.FreePattern('source')
PatternExpr_457 = da.pat.TuplePattern([da.pat.ConstantPattern('CTL_Done'), da.pat.FreePattern('rudata'), da.pat.FreePattern('rugroup_id')])
PatternExpr_466 = da.pat.FreePattern('source')
PatternExpr_705 = da.pat.TuplePattern([da.pat.ConstantPattern('Get_Stats'), da.pat.FreePattern('itr')])
PatternExpr_786 = da.pat.TuplePattern([da.pat.ConstantPattern('CTL_Start')])
PatternExpr_841 = da.pat.TuplePattern([da.pat.ConstantPattern('CTL_Terminate')])
PatternExpr_863 = da.pat.TuplePattern([da.pat.ConstantPattern('CTL_Stop')])
PatternExpr_791 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('CTL_Start')])])
PatternExpr_846 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('CTL_Terminate')])])
_config_object = {}
import sys
import time
import json
from itertools import chain

class WinResourceUsageData():
    'Tracks process time only.'

    def start(self):
        self.start_cputime = time.process_time()

    def end(self):
        self.end_cputime = time.process_time()
        self.results = {'Total_process_time': (self.end_cputime - self.start_cputime)}

    @classmethod
    def aggregate(cls, rudata_points):
        return {'Total_process_time': sum((p.results['Total_process_time'] for p in rudata_points)), 'Total_processes': len(rudata_points)}

class PosixResourceUsageData():
    'Tracks utime, stime, and maxrss.'

    def start(self):
        self.start_data = resource.getrusage(resource.RUSAGE_SELF)

    def end(self):
        self.end_data = resource.getrusage(resource.RUSAGE_SELF)

        def diff(attr):
            return (getattr(self.end_data, attr) - getattr(self.start_data, attr))
        self.results = {'Total_user_time': diff('ru_utime'), 'Total_system_time': diff('ru_stime'), 'Total_process_time': (diff('ru_utime') + diff('ru_stime')), 'Total_memory': self.end_data.ru_maxrss}

    @classmethod
    def aggregate(cls, rudata_points):

        def sumof(attr):
            return sum((p.results[attr] for p in rudata_points))
        aggr_results = {k: sumof(k) for k in ['Total_user_time', 'Total_system_time', 'Total_process_time', 'Total_memory']}
        aggr_results['Total_processes'] = len(rudata_points)
        return aggr_results
if (sys.platform == 'win32'):
    ResourceUsageData = WinResourceUsageData
else:
    import resource
    ResourceUsageData = PosixResourceUsageData

class Controller(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._ControllerReceivedEvent_2 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ControllerReceivedEvent_0', PatternExpr_430, sources=[PatternExpr_435], destinations=None, timestamps=None, record_history=None, handlers=[self._Controller_handler_429]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ControllerReceivedEvent_1', PatternExpr_457, sources=[PatternExpr_466], destinations=None, timestamps=None, record_history=None, handlers=[self._Controller_handler_456]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ControllerReceivedEvent_2', PatternExpr_705, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, nprocs, threshold=None, **rest_928):
        super().setup(nprocs=nprocs, threshold=threshold, **rest_928)
        self._state.nprocs = nprocs
        self._state.threshold = threshold
        self._state.parent = self.parent()
        if (self._state.threshold is None):
            self._state.threshold = self._state.nprocs
        self._state.ps = set()
        self._state.done_ps = set()
        self._state.readys = 0
        self._state.dones = 0
        self._state.sent_stop = False
        self._state.rudata_points = {}
        self._state.ctl_verbose = True

    def run(self):
        super()._label('_st_label_540', block=False)
        _st_label_540 = 0
        while (_st_label_540 == 0):
            _st_label_540 += 1
            if (self._state.readys == self._state.nprocs):
                _st_label_540 += 1
            else:
                super()._label('_st_label_540', block=True)
                _st_label_540 -= 1
        self.verboutput('Controller starting everyone')
        t1 = time.perf_counter()
        self.send(('CTL_Start',), to=self._state.ps)
        super()._label('_st_label_560', block=False)
        _st_label_560 = 0
        while (_st_label_560 == 0):
            _st_label_560 += 1
            if (self._state.dones == self._state.nprocs):
                _st_label_560 += 1
            else:
                super()._label('_st_label_560', block=True)
                _st_label_560 -= 1
        t2 = time.perf_counter()
        self.verboutput('Everyone done')
        self.send(('CTL_Terminate',), to=self._state.ps)
        jsondata = {}
        for (rugroup_id, points) in self._state.rudata_points.items():
            if (rugroup_id is None):
                continue
            jsondata[rugroup_id] = ResourceUsageData.aggregate(points)
        allpoints = list(chain(*self._state.rudata_points.values()))
        jsondata['All'] = ResourceUsageData.aggregate(allpoints)
        jsondata['Wallclock_time'] = (t2 - t1)
        jsonoutput = json.dumps(jsondata)
        json_output_mod = json.dumps(jsondata['All'])
        print(('###OUTPUT: ' + jsonoutput))
        parsed_data = json.loads(json_output_mod)
        wall_clk_time = (t2 - t1)
        t_usr_time = parsed_data['Total_user_time']
        t_sys_time = parsed_data['Total_system_time']
        t_procs_time = parsed_data['Total_process_time']
        t_mem = parsed_data['Total_memory']
        stat_data = (self._state.nprocs, wall_clk_time, t_usr_time, t_sys_time, t_procs_time, t_mem)
        super()._label('_st_label_702', block=False)
        itr = None

        def ExistentialOpExpr_703():
            nonlocal itr
            for (_, _, (_ConstantPattern720_, itr)) in self._ControllerReceivedEvent_2:
                if (_ConstantPattern720_ == 'Get_Stats'):
                    if True:
                        return True
            return False
        _st_label_702 = 0
        while (_st_label_702 == 0):
            _st_label_702 += 1
            if ExistentialOpExpr_703():
                self.send(('Stats', stat_data, itr), to=self.nodeof(self._id))
                _st_label_702 += 1
            else:
                super()._label('_st_label_702', block=True)
                _st_label_702 -= 1
        time.sleep(1)

    def verboutput(self, s):
        if self._state.ctl_verbose:
            self.output(s)

    def _Controller_handler_429(self, source):
        self._state.ps.add(source)
        self._state.readys += 1
        self.verboutput('Got Ready from {} ({}/{})'.format(source, self._state.readys, self._state.nprocs))
    _Controller_handler_429._labels = None
    _Controller_handler_429._notlabels = None

    def _Controller_handler_456(self, rudata, rugroup_id, source):
        self._state.dones += 1
        self._state.done_ps.add(source)
        self._state.rudata_points.setdefault(rugroup_id, []).append(rudata)
        if (self._state.threshold == self._state.nprocs):
            self.verboutput('Got Done from {} ({}/{})'.format(source, self._state.dones, self._state.nprocs))
        else:
            self.verboutput('Got Done from {} ({}/{}, need {} to stop)'.format(source, self._state.dones, self._state.nprocs, self._state.threshold))
        if ((self._state.dones >= self._state.threshold) and (not self._state.sent_stop)):
            rest_ps = (self._state.ps - self._state.done_ps)
            self.verboutput('Controller stopping everyone')
            self.send(('CTL_Stop',), to=rest_ps)
            self._state.sent_stop = True
    _Controller_handler_456._labels = None
    _Controller_handler_456._notlabels = None

class Controllee(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._ControlleeReceivedEvent_0 = []
        self._ControlleeReceivedEvent_1 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ControlleeReceivedEvent_0', PatternExpr_786, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ControlleeReceivedEvent_1', PatternExpr_841, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ControlleeReceivedEvent_2', PatternExpr_863, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Controllee_handler_862])])

    def setup(self, ctl, **rest_928):
        super().setup(ctl=ctl, **rest_928)
        self._state.ctl = ctl
        self._state.rudata = ResourceUsageData()
        self._state.ctl_verbose = True
        self._state.ctl_done = False

    def run(self):
        pass

    def verboutput(self, s):
        if self._state.ctl_verbose:
            self.output(s)

    def ctl_begin(self):
        self.send(('CTL_Ready',), to=self._state.ctl)
        super()._label('_st_label_783', block=False)
        _st_label_783 = 0
        while (_st_label_783 == 0):
            _st_label_783 += 1
            if PatternExpr_791.match_iter(self._ControlleeReceivedEvent_0, SELF_ID=self._id):
                _st_label_783 += 1
            else:
                super()._label('_st_label_783', block=True)
                _st_label_783 -= 1
        self._state.rudata.start()

    def ctl_end(self):
        self._state.ctl_done = True
        self._state.rudata.end()
        rugroup_id = getattr(self._id, 'ctl_rugroup_id', None)
        self.send(('CTL_Done', self._state.rudata, rugroup_id), to=self._state.ctl)
        super()._label('_st_label_838', block=False)
        _st_label_838 = 0
        while (_st_label_838 == 0):
            _st_label_838 += 1
            if PatternExpr_846.match_iter(self._ControlleeReceivedEvent_1, SELF_ID=self._id):
                _st_label_838 += 1
            else:
                super()._label('_st_label_838', block=True)
                _st_label_838 -= 1
        self.verboutput('Terminating...')

    def _Controllee_handler_862(self):
        self.verboutput('Received stop')
        if self._state.ctl_done:
            return
        self.ctl_end()
        self.exit()
    _Controllee_handler_862._labels = None
    _Controllee_handler_862._notlabels = None

def run(func):
    'Decorator for Process.run() to call controllee hooks.'

    def ctl_run(self):
        self.ctl_begin()
        func(self)
        self.ctl_end()
    return ctl_run

def rugroup(rugroup_id):
    'Decorator for annotating a process controllee subclass\n    with a resource usage group identifier. Results for processes\n    in the same group will be aggregated reported together.\n    '

    def f(proc):
        proc.ctl_rugroup_id = rugroup_id
        return proc
    return f
